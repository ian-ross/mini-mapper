\documentclass[a4paper,11pt,article]{memoir}

\usepackage[utf8]{inputenc}
\usepackage{fourier}
\usepackage{amsmath,amssymb}
\usepackage{xstring,ifthen,xcolor}
\usepackage{xspace}
\usepackage{url}

\usepackage{color}
\definecolor{orange}{rgb}{0.75,0.5,0}
\definecolor{magenta}{rgb}{1,0,1}
\definecolor{cyan}{rgb}{0,1,1}
\definecolor{grey}{rgb}{0.25,0.25,0.25}
\newcommand{\outline}[1]{{\color{grey}{\scriptsize #1}}}
\newcommand{\todo}[1]{{\color{red}\textit{\textbf{#1}}}}
\newcommand{\note}[1]{{\color{blue}\textit{\textbf{#1}}}}
\newcommand{\citenote}[1]{{\color{orange}{[\textit{\textbf{#1}}]}}}

\usepackage{tikz}
\usepackage{pgfmath}
\usetikzlibrary{calc,shapes,positioning}

\title{Mini-Mapper Software 1:\,Motor prototype board}
\author{Ian~Ross}

\graphicspath{{figs/}}

\begin{document}

\maketitle

These notes describe software development for the motor prototype
board for the Mini-Mapper robot. This is intended as a platform to
test motor driver and motor encoder setup, and to develop motor early
control algorithms (particularly constant-speed PID control and soft
start).

I'm intending to develop all the software for the Mini-Mapper as
``bare metal'' C++. Although I'll probably end up using an RTOS later
on (almost certainly FreeRTOS), I'm going to start with a simple event
loop without an RTOS. I'll use a Nucleo board with an STM32F767ZI
microcontroller on it for development experiments, and will choose a
suitable STM32 processor to put on the final Mini-Mapper boards based
on experiences using the Nucleo board. I'm not going to use any HAL
libraries from ST Micro because I'm interested in writing device
drivers myself.

The basic requirements I want to follow are:

\begin{description}
  \item[Language]{Firmware written in C++, maybe doing some
    experiments with Rust later on.}
  \item[Libraries]{Use only low-level CMSIS hardware definitions,
    writing my own C++ HAL.}
  \item[Build system]{Use Make for building, possibly adding Meson on
    top of this later on.}
  \item[IDE]{Use Emacs as an IDE, setting up the necessary tools for
    comfortable development.}
  \item[Communications]{Develop a command shell to run on the Nucleo
    board, talking to a PC over a USB serial port. This will make it
    easy both to do ad hoc experiments directly talking to the shell
    with Minicom, but also to write GUI front-ends for experiments and
    data collection using Python GTK or something similar. (This is
    the approach I used for my Teensy Load project, and I find it
    really useful.)}
  \item[STM32 features]{Clocks; power; USB serial (USART + DMA +
    interrupts); GPIOs and timers for PWM motor control; ADC for motor
    coil current sensing; GPIO input, interrupt and timer for motor
    encoder pulse detection.}
\end{description}

I want to cover the following topics in this prototyping phase:
\begin{enumerate}
  \item{Platform setup: clocks, power, etc.}
  \item{CMSIS familiarisation.}
  \item{Blinky: platform test, clock setup, GPIO setup.}
  \item{USART setup with interrupts for RX and DMA for TX.}
  \item{USB serial command shell.}
  \item{PWM demo: more GPIO setup, timer setup, USB serial control,
    view output using AD2.}
  \item{First pass experiment GUI: commanding of motor state (on/off,
    forward/backward, PWM duty cycle), monitoring of motor coil
    current and motor encoder pulses; data saving; real-time
    graphing.}
  \item{Encapsulation of \texttt{Motor}, \texttt{MotorEncoder} and
    \texttt{MotorController} abstractions.}
  \item{Constant speed PID control, including independent optical
    speed measurement.}
  \item{Soft start/ramp control.}
\end{enumerate}

This should be enough for the first ``direct control'' milestone.


\subsection{Initial setup}

\subsubsection{Platform and tools}

\begin{itemize}
  \item{I'm using the \texttt{arm-none-eabi} version of GCC, which is
    pretty standard.}
\end{itemize}

\subsection{CMSIS}

\begin{itemize}
  \item{The only files taken from the ST Micro-supplied code are the
    header files \texttt{stm32f767xx.h}, \texttt{stm32f7xx.h} and
    \texttt{core\_cm7.h} (and some compiler support files that they
    include), the startup file \texttt{startup\_stm32f767xx.s}, the
    linker script \texttt{STM32F767ZITx\_FLASH.ld}, and
    \texttt{system\_stm32f7xx.c}, which is a small file including a
    couple of support functions to help with clock setup.}
  \item{The header files provide register-level access to all the core
    functionality of the Cortex-M7 processor (\texttt{core\_cm7.h})
    and the peripherals provided on the STM32F767ZI
    (\texttt{stm32f767xx.h} and \texttt{stm32f7xx.h}).}
  \item{The \texttt{core\_cm7.h} also provides some basic functions
    for dealing with some core processor features, like cache control,
    the interrupt controller and the SysTick timer.}
  \item{I'm basically going to use anything in these files freely, and
    I'm happy to look at examples in the STM32 HAL code to work
    through any problems I have with my own HAL code, but I'm going to
    write more or less everything starting at the bare metal ``write
    to registers'' level, since this seems like the best way to get a
    good understanding of how things really work.}
\end{itemize}

\subsubsection{Blinky}


\subsection{Software architecture}


\subsection{USB serial shell}

\subsubsection{USART setup}


\subsubsection{Command shell}


\subsection{PWM demonstration}


\subsection{Experiment front-end GUI}


\section{Microcontroller setup}

The Nucleo board has an STM32F767ZI processor on it.

\subsection{Motor driver}

\begin{itemize}
  \item{The Toshiba motor driver has an application note where they
    seem to suggest using $f_{\mathrm{PWM}} = 30\,\mathrm{kHz}$.}
  \item{For a 10-bit resolution PWM duty cycle, this gives a clock
    frequency of $1024 \times 30\,\mathrm{kHz} = 30.72\,\mathrm{MHz}$.}
  \item{The clock input on Nucleo board is 8\,MHz by default. To use
    this, the STM32 should be set to run on the HSE clock (High-Speed
    External) with external bypass (\texttt{RCC\_CR:HSEBYP} = 1,
    \texttt{RCC\_CR:HSEON} = 1).}
  \item{The main clock PLL should be set up with
    \texttt{RCC\_PLLCFGR:PLLSRC} = 1 (HSE), \texttt{RCC\_PLLCFGR:PLLM}
    = 4 (VCO input: 2\,MHz), \texttt{RCC\_PLLCFGR:PLLN} = 128 (VCO
    output: 256\,MHz), \texttt{RCC\_PLLCFGR:PLLP} = 4 (PLL output:
    64\,MHz), and enabled with \texttt{RCC\_CR:PLLON} = 1.}
  \item{The APB prescalers need to be set to make the low-speed
    prescaler give a frequency of less than 45\,MHz:
    \texttt{RCC\_CFGR:PPRE1} = 4 (divide by 2 to give 32\,MHz).}
  \item{The system clock needs to be set to use the PLL:
    \texttt{RCC\_CFGR:SW} = 2.}
  \item{Using a 64\,MHz system clock and a 11-bit resolution PWM duty
    cycle yields a PWM frequency of 31.25\,kHz.}
\end{itemize}


\end{document}
